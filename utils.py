import pickle
from pathlib import Path
from subprocess import CalledProcessError, Popen, PIPE
import time
from timeit import default_timer

import feather
from IPython.display import display
import pandas as pd
from pandas_summary import DataFrameSummary


def create_or_load(train_path):
    """Reads dataset from a CSV file or previously saved binary formats."""

    temp_dir = train_path.parent / 'tmp'
    temp_dir.mkdir(parents=True, exist_ok=True)

    temp_data = temp_dir / 'data.feather'
    if temp_data.exists():
        print(f'Loading previously saved training data: {temp_data}')
        data = feather.read_dataframe(temp_data)
    else:
        print(f'Reading the CSV file with training data: {train_path}')
        data = pd.read_csv(train_path, low_memory=False)
        print(f'Saving data frame into feather file...')
        data.to_feather(temp_data)

    temp_summary = temp_dir / 'summary.pickle'
    if temp_summary.exists():
        print(f'Loading previously saved summary: {temp_summary}')
        state = pickle.load(temp_summary.open('rb'))
        summary = DataFrameSummary(pd.DataFrame())
        summary.__dict__.update(state)
    else:
        print('Generating summary statistics')
        summary = DataFrameSummary(data)
        print('Saving summary into pickle file...')
        with temp_summary.open('wb') as file:
            state = {'length': summary.length,
                     'columns_stats': summary.columns_stats,
                     'corr': summary.corr}
            pickle.dump(state, file)

    return data, summary


def show_all_columns(df):
    with pd.option_context('display.max_columns', None):
        display(df)
        
        
def show_all_rows(df):
    with pd.option_context('display.max_rows', None):
        display(df)


def show_all(df):
    with pd.option_context('display.max_columns', None, 'display.max_rows', None):
        display(df)
        

def create_submission_file(preds, identifier, filename='submit.csv'):
    with Path(filename).open('w') as f:
        f.write('MachineIdentifier,HasDetections\n')
        for i, machine_id in enumerate(identifier):
            f.write(f'{machine_id},{preds[i]:.8f}\n')
    return filename


def submit_to_kaggle(filename, message, competition='microsoft-malware-prediction'):
    cmd = f'kaggle c submit -c {competition} -f {filename} -m "{message}"'
    print(cmd)
    try:
        p = Popen(cmd, shell=True, stdout=PIPE, stderr=PIPE)
        stdout, stderr = p.communicate()
        if stdout is not None:
            print(stdout.decode('ascii'))
        if stderr is not None:
            print(stderr.decode('ascii'))
        rc = p.returncode
    except CalledProcessError as e:
        print(f'Submission failed! {e}')
        return False
    return rc == 0


class Timer:
    """Simple util to measure execution time.
    Examples
    --------
    >>> import time
    >>> with Timer() as timer:
    ...     time.sleep(1)
    >>> print(timer)
    00:00:01
    """
    def __init__(self):
        self.start = None
        self.elapsed = None

    def __enter__(self):
        self.start = default_timer()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.elapsed = default_timer() - self.start

    def __str__(self):
        return self.verbose()

    def __float__(self):
        return self.elapsed

    def verbose(self):
        if self.elapsed is None:
            return '<not-measured>'
        return self.format_elapsed_time(self.elapsed)

    @staticmethod
    def format_elapsed_time(value: float):
        return time.strftime('%H:%M:%S', time.gmtime(value))
